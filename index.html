<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Hot videos — 1-per-sub, cached, ultra-smooth</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E">
<style>
  :root{
    --overlay:linear-gradient(180deg, rgba(0,0,0,.7) 0, rgba(0,0,0,.35) 60%, transparent 100%);
    --title-pad: clamp(10px, 2.2vh, 16px);
    --title-size: clamp(14px, 2.1vh, 18px);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:#000;color:#fff;
    font-family:system-ui,Segoe UI,Inter,Roboto,Arial;
  }

  /* Full-viewport vertical scroller; hide scrollbar */
  #app{
    position:fixed; inset:0;
    height:100svh;
    overflow-y:scroll;
    scroll-snap-type:y mandatory;
    -webkit-overflow-scrolling:touch;
    background:#000;
    scrollbar-width:none; -ms-overflow-style:none;
  }
  #app::-webkit-scrollbar{width:0;height:0}

  .slide{
    position:relative; height:100svh; width:100%;
    scroll-snap-align:start; display:grid; place-items:center;
    background:#000; overflow:hidden; touch-action:manipulation;
    contain: layout paint;
  }

  /* Background blur fill */
  .bg{ position:absolute; inset:0; z-index:0; pointer-events:none; overflow:hidden; }
  .bg > img{
    position:absolute; inset:0; width:100%; height:100%;
    object-fit:cover; filter:blur(24px) brightness(.45); transform:scale(1.06);
    will-change:transform,filter;
  }

  /* Media: fully visible, any aspect ratio */
  .media{
    position:relative; z-index:1; width:100%; height:100%;
    display:grid; place-items:center;
  }
  .media > video, .media > iframe{
    width:100%; height:100%;
    object-fit:contain;
    max-width:100vw; max-height:100svh;
    display:block; background:transparent;
  }

  /* Thumb ABOVE the video until first painted frame (prevents black flash) */
  .thumb{
    position:absolute; inset:0; width:100%; height:100%;
    object-fit:contain; display:block; background:transparent;
    z-index:3; transition:opacity .14s linear;
  }

  /* Video fades in after first real frame; keep visible during loops */
  .media > video{
    opacity:0; transition:opacity .18s ease;
    z-index:2; will-change:opacity;
    background-color:transparent !important;
  }
  .media > video.is-playing{ opacity:1; }

  /* Title overlay at top: ALWAYS visible */
  .title{
    position:absolute; left:0; right:0; top:0; z-index:4;
    padding: calc(env(safe-area-inset-top) + var(--title-pad)) var(--title-pad) var(--title-pad);
    background:var(--overlay);
    font-weight:700; font-size:var(--title-size); line-height:1.25;
    text-shadow:0 1px 2px rgba(0,0,0,.7);
  }

  /* Loading badge (debounced programmatically, no flicker) */
  .loading-badge{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    display:none; align-items:center; gap:10px;
    padding:10px 12px; border-radius:999px;
    background-color: rgba(0,0,0,.45);
    backdrop-filter: blur(4px);
    font-size:13px; color:#e6e6e6;
    will-change:opacity;
    z-index:4;
  }
  .loading-badge .spinner{
    width:18px; height:18px; border:2px solid #666; border-top-color:#fff; border-radius:50%;
    animation:spin 0.9s linear infinite;
  }
  @keyframes spin{to{transform:rotate(360deg)}}

  .empty,.error{color:#bbb; text-align:center; padding:24px}
  .big-spinner{width:28px;height:28px;border:3px solid #333;border-top-color:#fff;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto}
</style>
</head>
<body>
<main id="app">
  <section class="slide">
    <div class="empty">
      <div class="big-spinner"></div>
      <div style="margin-top:10px">Loading first video…</div>
    </div>
  </section>
</main>

<script type="module">
  import { Geddit } from './geddit.min.js';

  // ---------- CONFIG ----------
  const QUERY_SUB = new URLSearchParams(location.search).get('sub'); // optional first sub override
  const CFG = {
    INCLUDE_NSFW: true,
    MIN_REQ_GAP_MS: 1200,
    MAX_PAGES_PER_PICK: 4,
    CANDIDATE_TRIES: 28,
    RECENT_WINDOW: 24,
    NEXT_PRELOAD: 'metadata',
    GLOBAL_BACKOFF_MS: 5000,
    HISTORY_BACK: 80,
    AHEAD_MAX: 3,
    BADGE_DELAY_MS: 160,
    BADGE_MIN_VISIBLE_MS: 250,
    SETTLE_DELAY_MS: 140,
    ACTIVATE_THRESHOLD: 0.75
  };

  // ---------- STATE ----------
  const api = new Geddit();
  const app = document.getElementById('app');

  const state = {
    subsList: [],
    lastReqAt: 0,
    backoffUntil: 0,

    // Cached timeline (stable order for temporal coherence)
    // { idx, sub, postId, kind: 'video'|'iframe'|'pending', src, poster, bg, title, playedOnce?:bool }
    timeline: [],
    rendered: new Map(),

    activeSlide: null,
    candidateSlide: null,
    ratios: new Map(),

    recentSubs: [],
    subProgress: new Map(),
    fillingIdx: new Set(),

    scrolling: false,
    settleTimer: null,
    settledAt: 0
  };

  // ---------- UTILS ----------
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const now = () => Date.now();
  const pick = arr => arr[(Math.random()*arr.length)|0];
  const unesc = s => (s||'').replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&quot;/g,'"').replace(/&#39;/g,"'");
  const isDirectVideo = u => /^https?:\/\//.test(u||'') && /\.(mp4|webm|m4v)$/i.test(u||'');
  const normalizeGifv = u => u && /\.gifv$/i.test(u) ? u.replace(/\.gifv$/i,'.mp4') : u;

  function posterOf(d){
    const p = d.preview?.images?.[0]?.source?.url;
    if (p) return unesc(p);
    const t = d.thumbnail;
    if (t && /^https?:\/\//.test(t) && !/(self|default|nsfw|image)/i.test(t)) return t;
    return '';
  }
  function redditVideoOf(d){
    const rv = d.secure_media?.reddit_video || d.media?.reddit_video;
    if (rv?.fallback_url) return rv.fallback_url;
    const pv = d.preview?.reddit_video_preview;
    if (pv?.fallback_url) return pv.fallback_url;
    return null;
  }
  function oembedSrcOf(d){
    const o = d.secure_media?.oembed || d.media?.oembed;
    if (!o?.html) return null;
    const frag = new DOMParser().parseFromString(o.html,'text/html');
    const ifr = frag.querySelector('iframe');
    return ifr ? ifr.getAttribute('src') : null;
  }
  function urlWithAutoplayLoop(src){
    try{
      const u = new URL(src, location.href);
      const host = u.hostname.toLowerCase();
      const set = (k,v)=>u.searchParams.set(k,v);
      set('autoplay','1'); set('muted','1'); set('playsinline','1'); set('loop','1');
      if (host.includes('youtube.com') || host.includes('youtu.be')){
        set('controls','0'); set('modestbranding','1'); set('rel','0'); set('enablejsapi','1');
        const id = u.hostname.includes('youtu.be')
          ? u.pathname.split('/')[1]
          : (u.pathname.match(/\/embed\/([^/?#]+)/)?.[1] || u.searchParams.get('v') || '');
        if (id) set('playlist', id);
      }
      if (host.includes('vimeo.com')) set('background','1');
      return u.toString();
    }catch{ return src; }
  }

  // ---------- GEDDIT (rate-gated) ----------
  async function rateGate(){
    let wait = 0;
    const t = now();
    if (t < state.backoffUntil) wait = Math.max(wait, state.backoffUntil - t);
    const since = t - state.lastReqAt;
    if (since < CFG.MIN_REQ_GAP_MS) wait = Math.max(wait, CFG.MIN_REQ_GAP_MS - since);
    if (wait) await sleep(wait);
    state.lastReqAt = now();
  }
  async function fetchHotPage(sub, after=null){
    try{
      await rateGate();
      const opts = { include_over_18: CFG.INCLUDE_NSFW };
      if (after) opts.after = after;
      const res = await api.getSubmissions('hot', sub, opts);
      if (!res || !Array.isArray(res.posts)) throw new Error('bad_response');
      return { items: res.posts.map(p=>p.data||p), after: res.after || null };
    } catch {
      state.backoffUntil = now() + CFG.GLOBAL_BACKOFF_MS;
      return { items: [], after: null };
    }
  }

  // ---------- SUB RECENCY ----------
  function getSubState(sub){
    if (!state.subProgress.has(sub)){
      state.subProgress.set(sub, { after: null, seen: new Set() });
    }
    return state.subProgress.get(sub);
  }
  function markSubUsed(sub){
    state.recentSubs.push(sub);
    if (state.recentSubs.length > CFG.RECENT_WINDOW) state.recentSubs.shift();
  }
  function pickRandomSubAvoidingRecent(tried){
    const recent = new Set(state.recentSubs);
    const pool = state.subsList.filter(s => !recent.has(s) && !tried.has(s));
    if (pool.length) return pick(pool);
    const pool2 = state.subsList.filter(s => !tried.has(s));
    if (pool2.length) return pick(pool2);
    return pick(state.subsList);
  }

  // ---------- PICK ONE PLAYABLE ----------
  async function pickOneUnseenFromSub(sub){
    const st = getSubState(sub);
    const seen = st.seen;
    let after = st.after;
    for (let page=0; page<CFG.MAX_PAGES_PER_PICK; page++){
      const { items, after: nextAfter } = await fetchHotPage(sub, after);
      if (!items.length) break;
      for (const d of items){
        const id = d.name || d.id;
        const rv = redditVideoOf(d);
        const direct = normalizeGifv(d.url_overridden_by_dest || d.url || '');
        const embed = oembedSrcOf(d);
        if (!seen.has(id) && (rv || isDirectVideo(direct) || embed)){
          seen.add(id);
          st.after = nextAfter || null;
          return d;
        }
      }
      after = nextAfter;
      if (!after) break;
    }
    return null;
  }
  async function chooseSubWithOneUnseen(){
    const tried = new Set();
    for (let i=0; i<CFG.CANDIDATE_TRIES; i++){
      const sub = (QUERY_SUB && state.timeline.length===0) ? QUERY_SUB : pickRandomSubAvoidingRecent(tried);
      tried.add(sub);
      const post = await pickOneUnseenFromSub(sub);
      if (post) return { sub, post };
    }
    return null;
  }

  // ---------- RECORD ----------
  function recordFromPost(sub, d){
    const title = d.title || '(untitled)';
    const bg = posterOf(d);
    const rv = redditVideoOf(d);
    const direct = normalizeGifv(d.url_overridden_by_dest || d.url || '');
    if (rv || isDirectVideo(direct)){
      return { idx: state.timeline.length, sub, postId:(d.name||d.id), kind:'video', src:(rv||direct), poster:bg||'', bg:bg||'', title, playedOnce:false };
    }
    const o = oembedSrcOf(d);
    if (o){
      return { idx: state.timeline.length, sub, postId:(d.name||d.id), kind:'iframe', src:urlWithAutoplayLoop(o), poster:'', bg:bg||'', title, playedOnce:false };
    }
    return null;
  }

  // ---------- BADGE (no flicker) ----------
  function getBadgeCtrl(el){
    if (el._badgeCtrl) return el._badgeCtrl;
    const badge = el.querySelector('.loading-badge');
    const ctrl = {
      visible:false,
      timer:null,
      lastChange:0,
      showDebounced(){
        if (!badge || this.visible) return;
        if (this.timer) return;
        this.timer = setTimeout(()=>{
          this.timer = null; this.visible = true; this.lastChange = now();
          badge.style.display = 'flex';
        }, CFG.BADGE_DELAY_MS);
      },
      hideStable(){
        if (!badge) return;
        const ensureHide = ()=>{ this.visible=false; this.lastChange=now(); badge.style.display='none'; };
        if (this.visible){
          const elapsed = now() - this.lastChange;
          if (elapsed >= CFG.BADGE_MIN_VISIBLE_MS) ensureHide();
          else setTimeout(ensureHide, CFG.BADGE_MIN_VISIBLE_MS - elapsed);
        } else if (this.timer){ clearTimeout(this.timer); this.timer=null; }
      }
    };
    el._badgeCtrl = ctrl;
    return ctrl;
  }

  // ---------- NO-FLASH REVEAL ----------
  function bindNoFlashReveal(slide, video){
    if (video._noFlashBound) return;
    video._noFlashBound = true;

    const thumb = slide.querySelector('.thumb');
    let revealed = false;

    const reveal = ()=>{
      if (revealed) return;
      revealed = true;
      video.classList.add('is-playing'); // fade in
      if (thumb){
        thumb.style.opacity = '0';
        thumb.addEventListener('transitionend', ()=>{ thumb.style.display='none'; }, { once:true });
      }
      getBadgeCtrl(slide).hideStable();
      const rec = state.timeline[+slide.dataset.idx]; if (rec) rec.playedOnce = true;
    };

    const showBadgeIfNeeded = ()=>{
      // show the badge only before first reveal; ignore during loops/buffer hiccups
      if (!revealed && !video.classList.contains('is-playing')) getBadgeCtrl(slide).showDebounced();
    };

    // Prefer exact first-painted-frame
    const onPlaying = ()=>{
      if ('requestVideoFrameCallback' in video){
        try {
          video.requestVideoFrameCallback(()=> reveal());
        } catch { reveal(); }
      } else {
        // Fallback: reveal on first >0s timeupdate
        const onTU = ()=>{
          if (video.currentTime > 0) { video.removeEventListener('timeupdate', onTU); reveal(); }
        };
        video.addEventListener('timeupdate', onTU);
        setTimeout(()=>{ if (!revealed) reveal(); }, 120);
      }
    };

    video.addEventListener('playing', onPlaying);

    // IMPORTANT: do NOT show loading on loops or after first reveal
    video.addEventListener('loadeddata', showBadgeIfNeeded);
    video.addEventListener('waiting', showBadgeIfNeeded);

    // Loop seamlessly without showing the badge
    video.addEventListener('ended', ()=>{
      // keep is-playing class; no badge; simply restart
      video.play().catch(()=>{});
    });

    video.addEventListener('error', ()=>{
      const badge = getBadgeCtrl(slide); badge.showDebounced();
      const s = slide.querySelector('.loading-badge span'); if (s) s.textContent = 'Tap to retry';
    });

    // Cached revisit: reveal immediately
    const rec = state.timeline[+slide.dataset.idx];
    if (rec?.playedOnce){
      reveal();
    }
  }

  // ---------- RENDER ----------
  function buildLoadingBadge(text='Loading video…'){
    const badge = document.createElement('div');
    badge.className = 'loading-badge';
    badge.innerHTML = `<div class="spinner"></div><span>${text}</span>`;
    return badge;
  }

  function buildBaseSlide(idx, kind, sub, bgUrl, titleText){
    const slide = document.createElement('section');
    slide.className = 'slide';
    slide.dataset.idx = String(idx);
    slide.dataset.kind = kind;
    slide.dataset.sub = sub || '';

    const bg = document.createElement('div'); bg.className = 'bg';
    const bgImg = document.createElement('img'); if (bgUrl) bgImg.src = bgUrl; bg.appendChild(bgImg);

    const mediaWrap = document.createElement('div'); mediaWrap.className = 'media';

    const title = document.createElement('div');
    title.className = 'title';
    title.textContent = titleText || '';

    slide.appendChild(bg); slide.appendChild(mediaWrap); slide.appendChild(title);
    observeSlide(slide);
    return slide;
  }

  function addVideo(slide, mediaWrap, rec){
    const v = document.createElement('video');
    v.dataset.src = rec.src;
    v.dataset.idx = String(rec.idx);
    v.preload = 'none';
    v.loop = true; v.muted = true; v.setAttribute('muted','');
    v.autoplay = false; v.controls = false;
    v.setAttribute('playsinline',''); v.setAttribute('webkit-playsinline','');
    v.disablePictureInPicture = true; v.disableRemotePlayback = true;
    v.playsInline = true;
    if (rec.poster) v.poster = rec.poster;

    mediaWrap.appendChild(v);
    bindNoFlashReveal(slide, v);
    return v;
  }

  function buildSlide(rec){
    const slide = buildBaseSlide(rec.idx, rec.kind, rec.sub, rec.bg, rec.title || '');
    const mediaWrap = slide.querySelector('.media');

    if (rec.kind === 'pending'){
      mediaWrap.appendChild(buildLoadingBadge('Fetching next video…'));
      return slide;
    }

    if (rec.poster){
      const img = document.createElement('img');
      img.className = 'thumb';
      img.loading = 'eager';
      img.decoding = 'async';
      img.src = rec.poster;
      mediaWrap.appendChild(img);
    }

    mediaWrap.appendChild(buildLoadingBadge());

    if (rec.kind === 'video'){
      addVideo(slide, mediaWrap, rec);
    } else if (rec.kind === 'iframe'){
      const ifr = document.createElement('iframe');
      ifr.src = 'about:blank';
      ifr.dataset.autoplaySrc = rec.src;
      ifr.allow = 'autoplay; fullscreen; picture-in-picture; encrypted-media';
      ifr.referrerPolicy = 'no-referrer-when-downgrade';
      ifr.frameBorder = '0';
      mediaWrap.appendChild(ifr);
    }
    return slide;
  }

  function insertSlideInOrder(el){
    const idx = +el.dataset.idx;
    const rendered = [...state.rendered.keys()].sort((a,b)=>a-b);
    const nextIdx = rendered.find(i => i > idx);
    if (nextIdx != null) app.insertBefore(el, state.rendered.get(nextIdx));
    else app.appendChild(el);
    state.rendered.set(idx, el);
    const ph = app.querySelector('.slide .empty');
    if (ph) app.querySelector('.slide').remove();
  }

  function ensureRendered(idx){
    if (state.rendered.has(idx)) return;
    const rec = state.timeline[idx];
    if (!rec) return;
    const el = buildSlide(rec);
    insertSlideInOrder(el);
  }

  // Upgrade pending → real in-place
  function upgradeSlideInPlace(idx, rec){
    const el = state.rendered.get(idx);
    if (!el) { ensureRendered(idx); return; }

    el.dataset.kind = rec.kind;
    el.dataset.sub  = rec.sub || '';

    const bgImg = el.querySelector('.bg img');
    if (bgImg){ bgImg.src = rec.bg || bgImg.src; }
    const title = el.querySelector('.title');
    if (title){ title.textContent = rec.title || title.textContent; }

    const mediaWrap = el.querySelector('.media');
    mediaWrap.innerHTML = '';

    if (rec.poster){
      const img = document.createElement('img');
      img.className = 'thumb';
      img.loading = 'eager';
      img.decoding = 'async';
      img.src = rec.poster;
      mediaWrap.appendChild(img);
    }
    mediaWrap.appendChild(buildLoadingBadge());

    if (rec.kind === 'video'){
      addVideo(el, mediaWrap, rec);
    } else {
      const ifr = document.createElement('iframe');
      ifr.src = 'about:blank';
      ifr.dataset.autoplaySrc = rec.src;
      ifr.allow = 'autoplay; fullscreen; picture-in-picture; encrypted-media';
      ifr.referrerPolicy = 'no-referrer-when-downgrade';
      ifr.frameBorder = '0';
      mediaWrap.appendChild(ifr);
    }

    if (el === state.candidateSlide && !state.scrolling) commitActive();
  }

  function unrender(idx){
    const el = state.rendered.get(idx);
    if (!el) return;
    slideObserver.unobserve(el);
    if (el.dataset.kind === 'video') detachSrc(el.querySelector('video'));
    if (el.dataset.kind === 'iframe') stopIframe(el.querySelector('iframe'));
    el.remove();
    state.rendered.delete(idx);
  }

  function enforceWindow(activeIdx){
    const min = Math.max(0, activeIdx - CFG.HISTORY_BACK);
    const max = Math.min(state.timeline.length - 1, activeIdx + CFG.AHEAD_MAX);
    for (let i=min; i<=max; i++) ensureRendered(i);
    for (const i of [...state.rendered.keys()]){
      if (i < min || i > max) unrender(i);
    }
  }

  // ---------- PLACEHOLDER → FILL ----------
  async function createPlaceholderNext(){
    const idx = state.timeline.length;
    const rec = { idx, sub:'', postId:null, kind:'pending', src:'', poster:'', bg:'', title:'Loading next…', playedOnce:false };
    state.timeline.push(rec);
    ensureRendered(idx);
    return idx;
  }

  async function fillPlaceholder(idx){
    if (state.fillingIdx.has(idx)) return;
    state.fillingIdx.add(idx);
    try{
      const pick = await chooseSubWithOneUnseen();
      if (!pick) return;
      const filled = recordFromPost(pick.sub, pick.post);
      if (!filled) return;

      filled.idx = idx;
      state.timeline[idx] = filled;
      markSubUsed(filled.sub);
      if (idx === 0) document.title = `r/${filled.sub} — hot videos`;

      upgradeSlideInPlace(idx, filled);
      updateCandidate();
      if (!state.scrolling) commitActive();
    } finally {
      state.fillingIdx.delete(idx);
    }
  }

  // ---------- INTERSECTION / CANDIDATE ----------
  const slideObserver = new IntersectionObserver((entries)=>{
    for (const e of entries) state.ratios.set(e.target, e.intersectionRatio);
    updateCandidate();
  }, { root: app, threshold: [0, CFG.ACTIVATE_THRESHOLD, 1] });

  function observeSlide(slide){ slideObserver.observe(slide); }

  function bestCandidate(){
    let best=null, rBest=CFG.ACTIVATE_THRESHOLD;
    for (const [el, r] of state.ratios.entries()){
      if (!app.contains(el)) { state.ratios.delete(el); continue; }
      if (r > rBest){ rBest=r; best=el; }
    }
    return best;
  }

  function updateCandidate(){
    const cand = bestCandidate();
    if (cand) state.candidateSlide = cand;

    if (state.candidateSlide){
      const idx = +state.candidateSlide.dataset.idx;
      const min = Math.max(0, idx - CFG.HISTORY_BACK);
      const max = Math.min(state.timeline.length - 1, idx + CFG.AHEAD_MAX);
      for (let i=min; i<=max; i++) ensureRendered(i);

      const needIdx = idx + 1;
      if (needIdx >= state.timeline.length){
        createPlaceholderNext().then(fillPlaceholder);
      }
    }
  }

  // ---------- SCROLL SETTLE ----------
  function onAnyScroll(){
    state.scrolling = true;
    if (state.settleTimer) clearTimeout(state.settleTimer);
    state.settleTimer = setTimeout(()=>{
      state.scrolling = false;
      state.settledAt = now();
      commitActive();
    }, CFG.SETTLE_DELAY_MS);
  }
  app.addEventListener('scroll', onAnyScroll, { passive:true });
  window.addEventListener('resize', onAnyScroll, { passive:true });
  window.addEventListener('wheel', onAnyScroll, { passive:true });
  window.addEventListener('keydown', (e)=>{
    const keys = ['PageDown','PageUp','Home','End','ArrowDown','ArrowUp','ArrowLeft','ArrowRight','Space'];
    if (keys.includes(e.code)) onAnyScroll();
  });

  // ---------- PLAYBACK ----------
  function attachSrc(v, mode){
    if (!v) return;
    if (!v.src && v.dataset.src){ v.src = v.dataset.src; v.preload = mode; v.load(); }
    else { v.preload = mode; }
  }
  function detachSrc(v){
    if (!v) return;
    v.pause();
    if (v.dataset.role !== 'prev'){
      if (v.src){
        if (!v.dataset.src) v.dataset.src = v.src;
        v.removeAttribute('src'); v.load();
      }
    }
    v.preload = 'none';
    v.classList.remove('is-playing');
  }
  function startIframe(ifr){ if (ifr){ const want = ifr.dataset.autoplaySrc || ''; if (ifr.src !== want) ifr.src = want; } }
  function stopIframe(ifr){ if (ifr && ifr.src !== 'about:blank') ifr.src = 'about:blank'; }
  function ensurePlay(v){
    if (!v) return;
    const play = ()=> v.play().catch(()=>{});
    if (v.readyState >= 2) play(); else { v.addEventListener('canplay', play, { once:true }); }
  }

  function primeRoles(activeIdx){
    for (const [idx, el] of state.rendered){
      const kind = el.dataset.kind;
      const role = idx === activeIdx ? 'active' : (idx === activeIdx - 1 ? 'prev' : (idx === activeIdx + 1 ? 'next' : 'other'));
      if (kind === 'video'){
        const v = el.querySelector('video'); if (!v) continue;
        v.dataset.role = role;

        if (role === 'active'){
          const rec = state.timeline[+el.dataset.idx];
          const revisit = rec?.playedOnce === true;

          attachSrc(v, 'auto');

          if (revisit){
            // Already decoded at least once → reveal and (re)play immediately
            v.classList.add('is-playing');
            const th = el.querySelector('.thumb');
            if (th && th.style.display !== 'none'){
              th.style.opacity='0';
              th.addEventListener('transitionend', ()=> th.style.display='none', {once:true});
            }
            getBadgeCtrl(el).hideStable();
            ensurePlay(v);
          } else {
            if (!state.scrolling){
              if (v.readyState < 2) getBadgeCtrl(el).showDebounced(); else getBadgeCtrl(el).hideStable();
              v.muted = true; v.setAttribute('muted','');
              v.setAttribute('playsinline',''); v.setAttribute('webkit-playsinline','');
              v.loop = true; ensurePlay(v);
            } else {
              getBadgeCtrl(el).showDebounced();
              v.pause();
            }
          }
        } else if (role === 'next'){
          attachSrc(v, CFG.NEXT_PRELOAD);
          getBadgeCtrl(el).hideStable();
          v.pause();
        } else if (role === 'prev'){
          // keep lightweight attachment for instant back-swipe replay
          attachSrc(v, 'metadata');
          getBadgeCtrl(el).hideStable();
          v.pause();
        } else {
          detachSrc(v); getBadgeCtrl(el).hideStable();
        }
      } else if (kind === 'iframe'){
        if (role === 'active'){
          if (!state.scrolling) startIframe(el.querySelector('iframe'));
        } else if (role === 'next'){
          startIframe(el.querySelector('iframe'));
        } else {
          stopIframe(el.querySelector('iframe'));
        }
        getBadgeCtrl(el).hideStable();
      } else if (kind === 'pending'){
        if (role === 'next' || role === 'active') fillPlaceholder(+el.dataset.idx);
      }
    }
  }

  function commitActive(){
    const cand = state.candidateSlide || bestCandidate();
    if (!cand) return;

    const activeIdx = +cand.dataset.idx;

    if (state.activeSlide !== cand){
      state.activeSlide = cand;
      enforceWindow(activeIdx);
    }
    primeRoles(activeIdx);

    const needIdx = activeIdx + 1;
    if (needIdx >= state.timeline.length){
      createPlaceholderNext().then(fillPlaceholder);
    }
  }

  // ---------- STARTUP ----------
  async function init(){
    try{
      const j = await fetch('./subreddits.json').then(r=>r.json());
      const list = Array.isArray(j) ? j
                : Array.isArray(j.Subreddits) ? j.Subreddits
                : Array.isArray(j.subreddits) ? j.subreddits
                : [];
      state.subsList = list.filter(Boolean).map(s=>String(s).replace(/^r\//i,'').trim()).filter(Boolean);
      if (!state.subsList.length) state.subsList = ['pics'];

      const idx0 = await createPlaceholderNext();
      await fillPlaceholder(idx0);

      ensureRendered(0);
      updateCandidate();
      state.scrolling = false;
      commitActive();
    } catch {
      const holder = app.querySelector('.slide');
      if (holder) holder.innerHTML = `<div class="error">Failed to load <code>subreddits.json</code> or initial video.</div>`;
    }
  }
  init();

  // Pause/resume on tab visibility
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden && state.activeSlide){
      if (state.activeSlide.dataset.kind === 'video') state.activeSlide.querySelector('video')?.pause();
      else state.activeSlide.querySelector('iframe')?.setAttribute('src','about:blank');
    } else commitActive();
  });
</script>
</body>
</html>
