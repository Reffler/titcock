<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TikTok-style RedGIFs feed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark light; }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: #0b0c10;
      color: #e8f0fe;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
      overflow: hidden; /* the scroller handles scroll */
    }

    /* Header shows current post title */
    header {
      position: fixed;
      top: 0; left: 0; right: 0;
      min-height: 52px;
      display: flex;
      align-items: center;
      padding: 10px 14px;
      background: linear-gradient(180deg, rgba(11,12,16,.9) 0%, rgba(11,12,16,.4) 60%, rgba(11,12,16,0) 100%);
      z-index: 5;
      pointer-events: none; /* let scroll pass through */
    }
    header h1 {
      margin: 0;
      font-size: clamp(12px, 2.5vw, 18px);
      font-weight: 600;
      letter-spacing: .2px;
      color: #c7d2fe;
      max-width: 92%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Global controls */
    .global-controls {
      position: fixed;
      right: 12px;
      bottom: 16px;
      display: flex;
      gap: 8px;
      z-index: 10;
      pointer-events: auto;
    }
    .btn {
      appearance: none;
      border: 1px solid rgba(99,102,241,.5);
      background: rgba(31,41,55,.6);
      color: #e8f0fe;
      padding: 8px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 12px;
      backdrop-filter: blur(6px);
    }
    .btn:hover { background: rgba(31,41,55,.8); }

    /* Vertical snap scroller */
    .scroller {
      position: fixed;
      inset: 0;
      overflow-y: auto;
      scroll-snap-type: y mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-y: contain;
    }

    .card {
      position: relative;
      height: 100vh;
      width: 100vw;
      scroll-snap-align: start;
      display: grid;
      place-items: center;
      background: #000;
      border-bottom: 1px solid #12151f;
      user-select: none;
    }

    /* Full (uncropped) video always visible */
    .inner {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: grid;
      place-items: center;
      background: #000;
      overflow: hidden;
    }
    video {
      width: 100%;
      height: 100%;
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;   /* ensures no cropping at any aspect ratio */
      background: #000;      /* letter/pillarbox bars */
      display: block;
    }

    /* Loading / error states */
    .spinner, .err {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .spinner:before {
      content: "";
      width: 38px;
      height: 38px;
      border-radius: 50%;
      border: 3px solid rgba(255,255,255,.15);
      border-top-color: rgba(255,255,255,.85);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .err {
      padding: 12px;
      color: #ffd7d7;
      background: linear-gradient(180deg, rgba(42,13,13,.7), rgba(42,13,13,.2));
      border-top: 1px solid #5b1b1b;
      border-bottom: 1px solid #5b1b1b;
      font-size: 13px;
      text-align: center;
      display: none;
    }

    /* End sentinel space */
    .end {
      height: 40vh;
      display: grid;
      place-items: center;
      color: #9ca3af;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <header><h1 id="headerTitle">Loading…</h1></header>

  <main id="scroller" class="scroller" aria-label="TikTok-style video feed">
    <!-- Cards get appended here -->
    <div id="sentinel" class="end">Loading…</div>
  </main>

  <div class="global-controls">
    <button id="muteBtn" class="btn" type="button">Unmute</button>
  </div>

  <script>
    (function () {
      "use strict";

      /* ===========================
         Config
      ============================ */
      // Chrome CORS-on-redirect fix: encode '+' in the multi to avoid redirect.
      const MULTI = "BiggerThanYouThought+TikTokNSFW";
      const FEED_URL = "https://www.reddit.com/r/" + encodeURIComponent(MULTI) + "/.json?raw_json=1";

      const PROXY = "https://api.codetabs.com/v1/proxy?quest=";
      const SNAP_PLAY_THRESHOLD = 0.6;  // % of card visible to switch playback
      const RATE_LIMIT_PER_SEC = 5;     // Codetabs documented limit
      const CACHE_CAP = 8;              // how many videos to keep attached (LRU)

      /* ===========================
         Helpers
      ============================ */
      const $ = (sel, el = document) => el.querySelector(sel);
      const $$ = (sel, el = document) => [...el.querySelectorAll(sel)];
      const encode = encodeURIComponent;

      // Token bucket limiter to *initiate* media loads at <=5/s.
      const limiter = (() => {
        let tokens = RATE_LIMIT_PER_SEC;
        const queue = [];
        setInterval(() => {
          tokens = Math.min(tokens + RATE_LIMIT_PER_SEC, RATE_LIMIT_PER_SEC);
          while (tokens > 0 && queue.length) {
            tokens--; queue.shift()();
          }
        }, 1000);
        return (fn) => {
          if (tokens > 0) { tokens--; fn(); }
          else { queue.push(fn); }
        };
      })();

      function proxied(url) {
        return PROXY + encode(url);
      }

      function byCaseFromThumb(thumbUrl) {
        // Example: https://media.redgifs.com/HideousUnpleasantApatosaur-poster.jpg
        const m = /media\.redgifs\.com\/([^\/?#]+)-poster/i.exec(thumbUrl || "");
        return m ? m[1] : null;
      }

      function lowerToGuessPascal(slug) {
        // Fallback if thumbnail not present; capitalize first letter.
        return slug ? slug.charAt(0).toUpperCase() + slug.slice(1) : null;
      }

      function iframeSlug(html) {
        // Extract slug from iframe HTML: <iframe src="https://www.redgifs.com/ifr/hideousunpleasantapatosaur" ...>
        const m = /redgifs\.com\/ifr\/([a-z0-9_]+)/i.exec(html || "");
        return m ? m[1].toLowerCase() : null;
      }

      function buildM4S(namePascal) {
        return `https://media.redgifs.com/${namePascal}-mobile.m4s`;
      }
      function buildMP4(namePascal) {
        return `https://media.redgifs.com/${namePascal}-mobile.mp4`;
      }

      /* ===========================
         Global state
      ============================ */
      const scroller = $("#scroller");
      const sentinel = $("#sentinel");
      const muteBtn = $("#muteBtn");
      const headerTitle = $("#headerTitle");

      let after = null;
      let fetching = false;
      let activeVideo = null;

      // "globalMuted" means "should the ACTIVE video be muted?"
      let globalMuted = JSON.parse(localStorage.getItem("globalMuted") ?? "true");

      // LRU list of videos with src attached (for caching)
      const retained = [];
      const seenSlugs = new Set(); // avoid duplicates across pages

      function retainVideo(v) {
        const i = retained.indexOf(v);
        if (i !== -1) retained.splice(i, 1);
        retained.push(v);
        evictIfNeeded();
      }

      function evictIfNeeded() {
        const keep = new Set();
        if (activeVideo) {
          keep.add(activeVideo);
          const { prev, next } = siblingsOf(activeVideo.closest(".card"));
          if (prev) keep.add($("video", prev));
          if (next) keep.add($("video", next));
        }
        while (retained.length > CACHE_CAP) {
          const candidate = retained[0];
          if (keep.has(candidate)) { retained.shift(); retained.push(candidate); continue; }
          try { candidate.pause(); } catch {}
          if (candidate.src) { candidate.removeAttribute("src"); candidate.load(); }
          retained.shift();
        }
      }

      function applyMuteState() {
        // Only the active video may reflect the "globalMuted" setting.
        // All others must stay muted to guarantee no audio leaks.
        $$(".card video").forEach(v => {
          v.muted = (v !== activeVideo) || globalMuted;
        });
        muteBtn.textContent = globalMuted ? "Unmute" : "Mute";
      }

      function setGlobalMuted(value) {
        globalMuted = Boolean(value);
        localStorage.setItem("globalMuted", JSON.stringify(globalMuted));
        applyMuteState();
        if (activeVideo) {
          // If user unmuted, make sure only active plays (and with sound)
          activeVideo.play().catch(()=>{});
        }
      }

      muteBtn.addEventListener("click", () => setGlobalMuted(!globalMuted));
      applyMuteState(); // init UI

      /* ===========================
         DOM builders
      ============================ */
      function cardDOM({ title, namePascal, slugLower }) {
        const card = document.createElement("section");
        card.className = "card";
        card.dataset.slug = slugLower || "";
        card.dataset.name = namePascal || "";
        card.dataset.title = title || "";

        const inner = document.createElement("div");
        inner.className = "inner";

        const v = document.createElement("video");
        v.setAttribute("playsinline", "");
        // No autoplay attribute; we control when to play.
        v.loop = true;
        v.preload = "metadata";
        v.crossOrigin = "anonymous";
        v.setAttribute("x-webkit-airplay","allow");
        v.controls = false;
        v.muted = true; // start muted until a card becomes active; applyMuteState() will adjust

        // No poster (prevents Redgifs 403 hotlink issues)

        v.dataset.srcM4S = proxied(buildM4S(namePascal));
        v.dataset.srcMP4 = proxied(buildMP4(namePascal));
        v.dataset.triedFallback = "0";

        const spinner = document.createElement("div");
        spinner.className = "spinner";

        const err = document.createElement("div");
        err.className = "err";

        function tryPlayIfActive(videoEl) {
          if (videoEl !== activeVideo) return; // only play the card in focus
          videoEl.play().catch((e) => {
            if (e && e.name === "NotAllowedError") {
              // Autoplay policy: force mute then retry
              setGlobalMuted(true);
              videoEl.play().catch(()=>{});
            }
          });
        }

        v.addEventListener("loadedmetadata", () => {
          spinner.style.display = "none";
          // Only attempt to play if this is the active video
          tryPlayIfActive(v);
        });

        v.addEventListener("error", () => {
          const tried = v.dataset.triedFallback === "1";
          if (!tried) {
            v.dataset.triedFallback = "1";
            limiter(() => {
              if (!v.src || v.src === v.dataset.srcM4S) {
                v.src = v.dataset.srcMP4;
                v.load();
                // don't auto-play neighbors; will play when/if it becomes active
                tryPlayIfActive(v);
                retainVideo(v);
              }
            });
          } else {
            spinner.style.display = "none";
            err.style.display = "grid";
            err.textContent = "Playback error. Scroll away and back, or try another browser.";
          }
        });

        inner.appendChild(v);
        inner.appendChild(spinner);
        inner.appendChild(err);
        card.appendChild(inner);
        return { card, video: v };
      }

      /* ===========================
         Feed loading / pagination
      ============================ */
      async function fetchPage() {
        if (fetching) return;
        fetching = true;
        sentinel.textContent = "Loading…";
        try {
          const url = FEED_URL + (after ? `&after=${encodeURIComponent(after)}` : "");
          const res = await fetch(url, { credentials: "omit", mode: "cors", redirect: "follow" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const json = await res.json();
          after = json?.data?.after || null;

          const items = (json?.data?.children || [])
            .map(x => x?.data)
            .filter(Boolean);

          const redgifs = [];
          for (const it of items) {
            const iframeHTML = it?.secure_media_embed?.content || it?.media_embed?.content || "";
            const slugLower = iframeSlug(iframeHTML) ||
                              /redgifs\.com\/watch\/([a-z0-9_]+)/i.exec(it?.url_overridden_by_dest || "")?.[1]?.toLowerCase() ||
                              null;
            if (!slugLower || seenSlugs.has(slugLower)) continue;

            const fromThumb = byCaseFromThumb(it?.secure_media?.oembed?.thumbnail_url);
            const namePascal = fromThumb || lowerToGuessPascal(slugLower);
            if (!namePascal) continue;

            seenSlugs.add(slugLower);
            redgifs.push({ title: it.title || "", namePascal, slugLower });
          }

          const frag = document.createDocumentFragment();
          for (const entry of redgifs) {
            const { card } = cardDOM(entry);
            frag.appendChild(card);
          }
          scroller.insertBefore(frag, sentinel);

          sentinel.textContent = after ? "Loading…" : "End of feed.";
        } catch (err) {
          sentinel.textContent = "Failed to load feed.";
          console.error(err);
        } finally {
          fetching = false;
        }
      }

      // Load first page immediately
      fetchPage();

      // Infinite scroll: when sentinel gets close, load more
      const moreObserver = new IntersectionObserver((entries) => {
        for (const e of entries) {
          if (e.isIntersecting && !fetching) {
            fetchPage();
          }
        }
      }, { root: scroller, threshold: 0.1 });
      moreObserver.observe(sentinel);

      /* ===========================
         Playback / caching management
      ============================ */
      const playObserver = new IntersectionObserver((entries) => {
        const visible = entries
          .filter(e => e.isIntersecting)
          .sort((a,b) => b.intersectionRatio - a.intersectionRatio);
        if (!visible.length) return;
        const targetCard = visible[0].target;
        activateCard(targetCard);
      }, { root: scroller, threshold: [0, SNAP_PLAY_THRESHOLD, 1] });

      const activityObserver = new MutationObserver(() => {
        $$(".card").forEach(c => playObserver.observe(c));
      });
      activityObserver.observe(scroller, { childList: true });

      function siblingsOf(card) {
        let prev = card.previousElementSibling;
        let next = card.nextElementSibling;
        while (prev && !prev.classList.contains("card")) prev = prev.previousElementSibling;
        while (next && !next.classList.contains("card")) next = next.nextElementSibling;
        return { prev, next };
      }

      function ensureAttached(v) {
        if (!v || v.src) return;
        limiter(() => {
          v.src = v.dataset.srcM4S; // first try M4S
          v.load();
          retainVideo(v);
        });
      }

      function activateCard(card) {
        if (!card) return;
        const v = $("video", card);
        if (activeVideo && activeVideo.closest(".card") === card) return;

        // Pause and hard-mute all others
        $$(".card video").forEach(x => {
          if (x !== v) {
            try { x.pause(); } catch {}
            x.muted = true;
          }
        });

        activeVideo = v;

        // Update header with this card's title
        headerTitle.textContent = card.dataset.title || "Untitled";

        // Attach src for current + neighbors (neighbors won't auto-play)
        const { prev, next } = siblingsOf(card);
        ensureAttached(v);
        if (prev) ensureAttached($("video", prev));
        if (next) ensureAttached($("video", next));

        applyMuteState(); // only active may be unmuted if globalMuted === false

        v.loop = true;
        v.play().catch(e => {
          if (e && e.name === "NotAllowedError") {
            setGlobalMuted(true);
            v.play().catch(()=>{});
          }
        });

        retainVideo(v);
        if (prev) retainVideo($("video", prev));
        if (next) retainVideo($("video", next));
        evictIfNeeded();
      }

      // On scroll end, ensure we activate the most centered card
      let scrollTimer = null;
      scroller.addEventListener("scroll", () => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          let best = null, bestDist = Infinity;
          $$(".card").forEach(card => {
            const rect = card.getBoundingClientRect();
            const cardMid = rect.top + rect.height / 2;
            const dist = Math.abs(cardMid - window.innerHeight / 2);
            if (dist < bestDist) { best = card; bestDist = dist; }
          });
          if (best) activateCard(best);
        }, 120);
      });

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          if (activeVideo) { try { activeVideo.pause(); } catch {} }
        } else {
          if (activeVideo) { limiter(() => activeVideo.play().catch(()=>{})); }
        }
      });
    })();
  </script>
</body>
</html>
